<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Wwwclient 0.9.1</title>
<style><!-- 
body {
	margin-left: 10%;
	margin-right: 10%;
	padding: 20pt;
	padding-top: 10pt;
	background: rgb(255,255,255);
	font:  10.5pt/15pt "Helvetica",Helvetica,sans-serif;
	color: rgb(80,80,80);
}

h1, h2, h3, h4 {
	font-family: "Trebuchet MS",Helvetica,sans-serif;
	color: rgb(22, 130, 178);
	font-weight: normal;
	padding-top: 0.5em;
	cursor: pointer;
}

hr {
	color: rgb(150, 220, 238);
	background: rgb(150, 220, 238);
	height: 1px;
	border: 0;
}


b {
	color: rgb(22,130,178);
}

strong {
	color: rgb(103,183,0);
}


a:link, a:active, a:visited {
	color: rgb(22,130,178);
	text-decoration: none;
}

a:hover {
	text-decoration: none;
	background-color: #dbecf4;
}

aimg {
	border: 0;
}

#header, #footer {
	font-size: 7pt;
	clear: both;
	width: 100%;
	color: rgb(177,208,223);
}

.kiwiContent {
	text-align: left;
}


#footer {
	padding-top:  30pt;
	text-align: right;
}

/*  Kiwi-specific  */

.title {
	margin-bottom: 0;
}

.kiwiMeta {
	max-width: 700px;
	padding: 5pt;
	margin-bottom:  2em;
	border-top:  1px solid rgb(150, 220, 238);
	background-color: rgb(250,250,250);
}

.kiwiMeta tr td {
	color: rgb(22, 130, 178);
}

.kiwiMeta tr td.name {
	font-weight: bold;
}

.kiwiContent {
	max-width: 700px;
}

.kiwiContent .heading .number {
	padding-right: 8pt;
}

.kiwiContent .heading .number .lastDot {
	display: none;
}


.kiwiContent .heading .number .level0 .lastDot {
	display: inline;
}

.kiwiContent h1 {
	font-size: 1.8em;
	font-weight: bold;
	margin-top: 1.5em;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h2 {
	font-size: 1.4em;
	font-weight: bold;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h3 {
	font-size: 1.2em;
	font-weight: normal;
}

.kiwiContent pre {
	padding: 5pt;
	border:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	background-color: rgb(240,240,250);
	font-size: 8pt;
	color: rgb(22,130,178);
}

.kiwiContent code {
	font-size: 8pt;
	background-color: rgb(240,240,250);
}

.kiwiContent dt {
	color: rgb(22,130,178);
	font-weight: bold;
}

.kiwiContent dd {
	border-left:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	margin-bottom: 2em;
}

.kiwiContent dd pre {
}

.kiwiContent ul {
	padding-top: 0em;
	margin-top: 0em;
}

.kiwiContent ul li {
	padding-bottom: 0.2em;
}

.kiwiContent ul li.todo {
	list-style-type: square;
}

.kiwiContent ul li.todo.done {
	text-decoration: line-through;
}

.kiwiContent table {
	border:  1px solid rgb(150, 220, 238);
	padding: 0pt;
}

.kiwiContent table caption {
	font-family: serif;
	padding-top: 1em;
	padding-bottom: 0.5em;
	font-style: italic;
	font-size: 90%;
	color: rgb(22, 130, 178);
}

.kiwiContent table tbody {
}

.kiwiContent table tr {
	margin: 0;
}

.kiwiContent table tr td {
	margin: 0;
	padding: 5pt;
	font-size: 90%;
	min-width: 125px;
	background-color: rgb(250,250,250);
	border-bottom: 1px solid rgb(150, 220, 238);
}

.kiwiContent table tr td.lastRow {
	border-bottom: none;
}

.kiwiContent table tr td.lastCol {
	border-right: none;
}

.kiwiContent table tr.even td {
	background-color: #FEFEFE;

}

.kiwiContent table tr.odd td {
	background-color: rgb(240,240,240);
}

.kiwiContent .term {
	color: rgb(22, 130, 178);
	background: rgb(240, 250, 256);
}

.kiwiContent .quote {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent .citation {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent div[class^="ann"] {
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	color: rgb(100, 100, 100);
}

.kiwiContent div[class^="ann"] .title {
	font-weight: bold;
}

.kiwiContent .annNote {
	border:  1px solid rgb(103,183,0);
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	background: #fffbe4;
	color: rgb(100, 100, 100);
	border:  1px solid #dedac3;
}

.kiwiContent .annNote .title {
	font-weight: bold;
	display: none;
}

.kiwiReferences {
	font:  8pt/12pt "Lucida Grande",Lucida,sans-serif;
	margin-top: 10pt;
	padding: 5pt;
	border-top:  1px solid rgb(200, 200, 200);
	background-color: rgb(250,250,250);
	color: rgb(200, 200, 200);
	font-size: 8pt;
}
.kiwiReferences a:link, .kiwiReferences a:active, .kiwiReferences a:visited {
	color: rgb(150,150,150);
}

.kiwiReferences .entry {
	padding-top: 5pt;
	clear: both;
}

.kiwiReferences .entry .name {
	float: left;
	font-weight: bold;
	padding-right: 5pt;
}

.kiwiReferences .entry .content {
	text-align: right;
}

 --></style>
</head>
<body>
<div
	class="title"><h1>Wwwclient 0.9.1</h1><h2>Advanced Web Browsing, Scraping And Automation</h2></div><table class='kiwiMeta'><tr><td width='0px' class='name'>Author</td><td width='100%' class='value'>Sébastien Pierre</td></tr><tr><td width='0px' class='name'>Date</td><td width='100%' class='value'>21-Sep-2006</td></tr><tr><td width='0px' class='name'>Update</td><td width='100%' class='value'>26-Jul-2008</td></tr></table>
<div class="kiwiContent"><div class='content'><p>Python has some well-known web automation and processing tools such as <a href="http://wwwsearch.sourceforge.net/mechanize/" class="external">Mechanize</a>, <a href="http://twill.idyll.org/" class="external">Twill</a> and <a href="http://www.crummy.com/software/BeautifulSoup/" class="external">BeautifulSoup</a>. All provide powerful operations to automatically browse and retrieve information from the web.</p><p>However, we experienced limitations using Twill (which is based on Mechanize and BeautifulSoup), notably the fact that it was difficult to <em>fine tune the HTTP requests</em>, or when the <em>HTML file was broken</em> (and you can't imagine how many HTML files are broken).</p><p>We decided to address these limitations by building a library that would allow to write web clients, using a high-level programming interface, while also allowing fine-grained control over the HTTP communication level.</p><p>WWWClient is a web browsing, scraping and automation client and library that can easily be used using an interpreter (like <code>ipython</code>) or embedded within a program. WWWClient offers both a high-level API and fine-grain control over low-level HTTP and web specific elements, as well as a powerful scraping API that lets you manipulate your HTML document using string, list and tree operations at the same time.</p><p>WWWClient is separated in four main modules:</p><ul><li>The <code>wwwclient.client</code> module defines the abstract interface for an HTTP client. Two implementations are available: one using Python httplib module, the other using Curl Python bindings.</li></ul><ul><li>The <code>wwwclient.browse</code> module defines the high-level, browser-like interface that allows to easily browse a website. This includes session and cookie management.</li></ul><ul><li>The <code>www.scrape</code> module offers a set of objects and operations to easily parse and get information from an HTML or XML document. It is made to be versatile and very tolerant to malformed HTML.</li></ul><ul><li>The <code>www.forms</code> module offers a set of objects to represent and manipulate forms easily, while maintaining the most flexibility.</li></ul><p>The forthcoming sections will present the <em>browsing</em> and <em>scraping</em> modules in detail. For information on the rest of WWWClient, the best source is the API documentation (included as <a href="#WWWCLIENT-API.HTML" class="internal">wwwclient-api.html</a>in the distribution)</p><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span>Browsing</h1><div class="level1"><p>The <span class='term'>browsing module</span> (<code>wwwclient.browse</code>) is the module you will probably use the most often, because it allows to mimic a web browser and to post and retrieve web data.</p><p>Before going in more details, it is important to understand the basic concepts behind HTTP and how they are reflected in the browsing API.</p><p>One can express a conceptual model of the elements of an WWW client-server interaction as follows:</p><ul><li><span class='term'>Requests</span> and <span class='term'>responses</span> are the atomic elements of communication. Requests have a method, a request URL, headers and a body. Responses have a response code, headers and a body.</li></ul><ul><li>A <span class='term'>transaction</span> is the sequence of messages starting with a request and all the related (provisional and final) responses.</li></ul><ul><li>A <span class='term'>session</span> is a set of transaction that are "conceptually linked". Session cookies are the usual way to express this link in requests and responses.</li></ul><p>These concepts are respectively implemented as <code>Request</code>, <code>Response</code>, <code>Transaction</code> and <code>Session</code> classes within the browse module. The <code>Session</code> class being the highest-level object, this is the one you are the most likely to use.</p><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">1<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Accessing a website</h2><div class="level2"><p>To access a website, you first need to create a new <code>Session</code> instance, and give it a URL :</p><pre>from wwwclient import browse
session = browse.Session("www.google.com")</pre><p>Alternatively, you can create a blank session, and browse later:</p><pre>session = browse.Session()
session.get("www.google.com")</pre><p>Once you have initiated your session, you usually call any of the following operations:</p><ul><li><code>get()</code> will send a <code>GET</code> request to the given URL </li><li><code>post()</code> wil send a <code>POST</code> request to the given URL </li><li><code>page()</code> will return you the HTML data of the current (last) page </li><li><code>last()</code> will return you the current (last) transaction</li></ul><p>You also have convenience method such as <code>url()</code>, <code>referer()</code>, or <code>status()</code>, <code>headers()</code> and <code>cookies()</code> which give you instant access to last transaction or session information. See the API for all the details.</p><p>So usually, the usage pattern is as follows:</p><pre>session    = browse.Session("http://www.mysite.com")
some_page  = session.get("some/page.html").data()
...
other_page = session.get("some/other/page.html").data()
...</pre><p>Note that every time that you do a <code>get</code> or a <code>post</code>, a <code>Transaction</code> instance is returned. Transactions give you interesting information about "what happened" in the response :</p><ul><li>the <code>newCookies()</code> method will tell you if cookies were set in the response </li><li>the <code>cookies()</code> method will return you the current cookie jar (the sesssion cookie merged with the new cookies) </li><li>the <code>redirect()</code> method will tell you if the response redirected you to somewhere.</li></ul><p>And you also have a bunch of other useful methods documented in the API.</p><div class='annNote'><div class='title'>note</div><div class='content'>
        You can also directly print a transaction or pass it through the <code>str</code>
        method to get its response data.</div></div><p>If it important to tell that you can give <code>get</code> and <code>post</code> two parameters that will influence the way resulting transactions are processed :</p><ul><li>The <code>follow</code> parameter tells if redirections should be followed. If not you will have to do manually something like :</li></ul><pre>t = session.get("page.html",follow=False)
while t.redirect(): t = session.get(t.redirect())</pre><ul><li>The <code>do</code> parameter tells if the transaction should be executed now or later. If the transaction is not executed, you can call the <code>do()</code> transaction method at any time. This allows to prepare transactions and execute them at will.</li></ul><p>Now that you know the basics of browsing with WWWClient, let's see how to post data.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">1<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Posting data</h2><div class="level2"><p>Posting data is usually the most complex thing you have to do when working on web automation. Because you can post data in many different ways, and because the server to which you post may react differently depending on what and how you post it, we worked hard to ensure that you have the most flexibility here.</p><p>There are different ways to communicate data to an HTTP server. WWWClient browsing and HTTP client modules offer different ways of doing so, depending on the type of HTTP request you want to issue:</p><dl><dt> 1) Posting with GET and values as parameters</dt><dd><div class='content'><pre> session.get("http://www.google.com", params={"name":"value", ...)
 GET http://www.google.com?name=value
</pre> Here you simply give your parameter as arguments, and they are automatically url-encoded in the request URL.</div></dd><dt> 2) Posting with POST and values as parameters</dt><dd><div class='content'><pre> session.post("http://www.google.com", params={"name":"value", ...)
 POST http://www.google.com?name=value
</pre> Just as for the <code>GET</code> request, you give the parameters as arguments, and they get url-encoded in the request URL.</div></dd><dt> 3) Posting with POST and values as url-encoded data</dt><dd><div class='content'><pre> session.post("http://www.google.com", data={"name":"value", ...)
 POST http://www.google.com
 ...
 Content-Length: 10
 name=value
</pre> By giving your values to the <code>data</code> argument instead of the <code>params</code> argument, you ensure that they get url-encoded and passed as the request body.</div></dd><dt> 4) Posting with POST and values as form-encoded data</dt><dd><div class='content'><pre> session.post("http://www.google.com", fields={"name":"value", ...)
 POST http://www.google.com
 ...
 Content-Type: multipart/form-data; boundary= ...
 ------------fbb6cc131b52e5a980ac702bedde498032a88158$
 Content-Disposition: form-data; name="name"
 
 value
 ------------fbb6cc131b52e5a980ac702bedde498032a88158$
 ...
</pre> Here the given fields is directly converted as a <code>multipart/form-data</code> body.</div></dd><dt> 5) Posting with POST and values as custom data</dt><dd><div class='content'><pre> session.post("http://www.google.com", data="name=value")
 POST http://www.google.com
 ...
 Content-Length: 10
 name=value
</pre> You can always submit your own data manually if you prefer. In this case, simply give a string with the desired request body.</div></dd><dt> 6) Posting files as attachment</dt><dd><div class='content'><pre> attach = session.attach(name="photo", filename="/path/to/myphoto.jpg")
 session.post("http://www.mysite/photo/submit", attach=attach)</pre><p>This enables sending a file as attachment to the given URL. This is a rather <em>low-level</em> functionaly, and you will most likely want to use the <code>submit()</code> method of session that allows you to submit data. This is the purpose of the next section.</p></div></dd></dl><p>In some cases, you will want your data/arguments to be posted in a specific order. To do so, WWWClient offers you the <code>Pairs</code> class, which is actually used to internally represent headers, cookies and parameters.</p><p><code>Pairs</code> are simply ordered sets of (key, value) pairs. Using pairs, you can very easily specify an order for your elements, and then ensure that the requests you send are <em>exactly</em> how you want them to be.</p><div class='annNote'><div class='title'>note</div><div class='content'>
        When specifying the <code>data</code> argument to <code>post()</code>, you cannot use
        the <code>fields</code> or <code>attach</code> arguments : they are exclusive.<br />        Also, for any more detail on the arguments and/or behaviour of any of
        these functions, have a look at the <code>wwwclient.client</code> API
        documentation.</div></div></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">1<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Submitting forms</h2><div class="level2"><p>We've seen how to post data to web servers, using the session <code>post()</code> method. WWWClient offers in addition to that a <code>submit()</code> method that interfaces with the <span class='term'>scraping module</span> to retrieve the forms description and prepare the data to be posted.</p><p>To get the forms available in your current session, you can do:</p><pre>&gt;&gt;&gt; session.forms()
{'formname':&lt;Form instance...&gt;, 'otherform':..., ...}</pre><p>Which will return you a <code>dict</code> with form names as keys and <code>scrape.Form</code> instances as values. Alternatively, you can use <code>session.form()</code> to have the first form declared in the document (useful when you know that there is only a single form).</p><p>Each form object can be easily manipulated using the following methods:</p><pre>form.fields()</pre><p>This will return a list of dictionaries representing the input elements constituting the form (that is <code>input</code>, <code>select</code>, <code>textarea</code>).</p><p>Each dict contains the attributes of the HTML element. For select and textarea, the <code>type</code> and <code>value</code> attributes are set to the current value (selected option or text area content).</p><pre>&gt;&gt;&gt; print form.fields()[0]
{'name':'user', 'type':'text', value:''}</pre><p>This gives you the full details of the fields, but you can also get a shorter version with only the names:</p><pre>&gt;&gt;&gt; print form.fieldNames()
('name',...)</pre><p>You may be tempted to change the value of a field directly, but you should <em>use the set() method instead</em> :</p><pre>form.set('user', ...)</pre><p>this is a better option, because changing the field value attribute will overwrite the default form value, while using the <code>set()</code> method will indicate that you specified a custom value for the field (which can be later cleared, so that the form object can be reused).</p><div class='annNote'><div class='title'>note</div><div class='content'>
        If you set values for <span class='term'>checkboxes</span>, they will be converted to <code>on</code> or
        <code>off</code>, unless their value is None, in which case they will be considered
        as undefined</div></div><p>Aside from fields, you can have a list of the form <code>actions</code>, which are actually the inputs with <code>type=submit</code>.</p><pre>form.actions()</pre><p>this will return a list of actions (the <code>submit</code> elements`) that you can trigger when submitting the form. Here is an example:</p><pre>&gt;&gt;&gt; Session("www.google.com").forms().actions()
[{'type': 'submit', 'name': 'btnG', 'value': 'Google Search'}, 
 {'type': 'submit', 'name': 'btnI', 'value': "I'm Feeling Lucky"}]</pre><p>To submit your form, you can use the session <code>submit()</code> method, which takes the following arguments:</p><ul><li><code>action</code>, which is the form action (from <code>form.actions()</code>) you would like to use when submitting. If no action is specified, no default action will be choosen.</li></ul><ul><li><code>values</code> is a dict of values that should be merged with the form already set and default values (note that it does not change the form values, such as what the form <code>set()</code> method does).</li></ul><ul><li><code>attach</code> is a list of attachments (created with the session <code>attach()</code> method) that should be submitted with the form.</li></ul><ul><li><code>method</code> is the HTTP method to use in the submission. If you specify attachments, then <code>POST</code> is required (and it is the default)</li></ul><ul><li><code>strip</code> tells if fields with empty values should be present within generated request body. By default it is <code>True</code>, which is sensible in most cases. However, if your request fails, you should try to set <code>strip</code> to <code>False</code> and see if it succeeds like that.</li></ul><p>The session <code>submit(form)</code> method will actually invoke the form <code>submit()</code> method, and then pass the result to the session <code>post</code> or <code>get</code> method. So if you want to see how the forms creates a "submission request body", have a look at the <code>wwwclient.form.Form.submit()</code> method.</p><div class='annNote'><div class='title'>note</div><div class='content'>
        When <span class='term'>submitting forms</span>, you can specify whether you want <span class='term'>fields with no values</span> to be <span class='term'>stripped</span> or not. Depending on how the server is
        implemented, this may cause your request to be incorrectly processed or
        not.<br />        If your request fails to be processed properly, try changing the value
        of the <code>strip</code> parameter in form submission methods.</div></div></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">2<span class="lastDot dot">.</span></span></span>Scraping</h1><div class="level1"><p>We've seen how to browse, post data and how to submit forms. We've also briefly mentioned that the forms submission relies on the scraping module to extract information from the last transaction response data.</p><p>In this section, we will see into detail how to use the scraping module to manipulate and extract parts of an HTML document.</p><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Tag list and tag tree</h2><div class="level2"><p>We all know that browsers are very tolerant to crappy HTML, and that there are many ways to read and process an HTML document. Most existing tools will try to convert your document to a tree object with a DOM-like interface, which is actually very useful, but not all the time, and sometimes blatantly fails to create a useful representation of your HTML document.</p><p>WWWClient scraping module is based on the principle that <em>you should be able to scrape HTML using string, list or tree operations</em>, because it is sometimes easier to identify a substring, extract it, and then work on it as subset of your HTML document.</p><p>For instance, say you want to extract the &ldquo;<span class='quote'>most popular projects</span>&rdquo; from the <a href="http://www.freshmeat.net" class="external">Freshmeat</a> home page. By looking at the HTML, you will see that this information is contained in a table, like that :</p><pre>  &lt;b&gt;MOST POPULAR PROJECTS&lt;/b&gt;
&lt;/div&gt;
&lt;table border="0" cellpadding="2" cellspacing="0"&gt;
...
&lt;/table&gt;
&lt;br&gt;
&lt;!-- DoubleClick Ad Tag --&gt;</pre><p>In this respect, it would be very easy to get the table by looking for the <code>"MOST POPULAR PROJECTS"</code> string and then for the <code>"&lt;!-- DoubleClick Ad"</code> right after, extract the substring between these two markers and process it.</p><p>To do so, WWWClient offers you operations to construct a <span class='term'>list of tags</span> from an HTML string (or substring), and then to &ldquo;<span class='quote'>fold</span>&rdquo; this list of tags into a tree. The lists and tree can both be converted to the exact HTML string they represent, and you can switch anytime between the list and tree representations.</p><div class='annNote'><div class='title'>note</div><div class='content'>
        WWWClient tag list and tag tree were designed to be completely faithful
        to the original HTML. That means that if you convert a tag list or a tag
        tree to HTML, you will have <em>exactly</em> the same HTML string as the one
        you used to construct the structure.</div></div><p>As an illustration, the Freshmeat most popular projects table looks like that:</p><pre>  &lt;tbody&gt;&lt;tr valign="top"&gt;
    &lt;td align="right"&gt;1.&lt;/td&gt;
    &lt;td&gt;&lt;a href="/projects/mplayer/"&gt;&lt;b&gt;&lt;font color="#000000"&gt;MPlayer&lt;/font&gt;&lt;/b&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;td align="right"&gt;100.00%&lt;/td&gt;
  &lt;/tr&gt;
        &lt;tr valign="top"&gt;
    &lt;td align="right"&gt;2.&lt;/td&gt;

    &lt;td&gt;&lt;a href="/projects/linux/"&gt;&lt;b&gt;&lt;font color="#000000"&gt;Linux&lt;/font&gt;&lt;/b&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;td align="right"&gt;81.03%&lt;/td&gt;
  &lt;/tr&gt;
  ... 
  &lt;/tbody&gt;</pre><p>When you convert it to a list using the <code>wwwclient.scrape</code> <code>HTML.list()</code> function, you get this:</p><pre>['&lt;tbody&gt;',
'&lt;tr valign="top"&gt;', '\n    ', '&lt;td align="right"&gt;',
'1.', '&lt;/td&gt;', '\n    ', '&lt;td&gt;', '&lt;a href="/projects/mplayer/"&gt;', '&lt;b&gt;',
'&lt;font color="#000000"&gt;', 'MPlayer', '&lt;/font&gt;', '&lt;/b&gt;', '&lt;/a&gt;', '&lt;/td&gt;',
'\n    ', '&lt;td align="right"&gt;', '100.00%', '&lt;/td&gt;', '\n  ', '&lt;/tr&gt;', '\n        ',
'&lt;tr valign="top"&gt;', '\n    ', '&lt;td align="right"&gt;',
'2.', '&lt;/td&gt;', '\n\n    ', '&lt;td&gt;', '&lt;a href="/projects/linux/"&gt;', '&lt;b&gt;',
'&lt;font color="#000000"&gt;', 'Linux', '&lt;/font&gt;', '&lt;/b&gt;', '&lt;/a&gt;', '&lt;/td&gt;', '\n    ',
'&lt;td align="right"&gt;', '81.03%', '&lt;/td&gt;', '\n  ', '&lt;/tr&gt;', '\n        ',
....</pre><p>when folded into a tree, or when you call <code>HTML.tree()</code>, you get something like that:</p><pre>#root
+-- tbody#0@1:
    +-- tr#1@2:valign=top
        +-- #text:'\n    '
        +-- td#2@3:align=right
            +-- #text:'1.'
        +-- #text:'\n    '
        +-- td#3@3:
            +-- a#4@4:href=/projects/mplayer/
                +-- b#5@5:
                    +-- font#6@6:color=#000000
                        +-- #text:'MPlayer'
        +-- #text:'\n    '
        +-- td#7@3:align=right
            +-- #text:'100.00%'
        +-- #text:'\n  '
    +-- #text:'\n        '
    +-- tr#8@2:valign=top
        +-- #text:'\n    '</pre><p>this tree representation shows you the <code>nodename#number@depth</code> where the number is the number of the node within the tree and the <code>depth</code> is the number of ancestors of the node. All this information will be very useful when you will want to manipulate the data and extract the information you need.</p><p>For the moment, all you need to know is that you can switch at any moment between the string, the <span class='term'>tag list</span> and the <span class='term'>tag tree</span> representation of your documents, or <span class='term'>fragments of it</span>.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Getting to the desired data</h2><div class="level2"><p>Let's start with a simple example: we want to search the web using Google and retrieve the searched items as a list.</p><p>The first step is to get the desired data using the <span class='term'>browsing</span> module:</p><pre>from wwwclient import browse, scrape
s = browse.Session("http://www.google.com")
f = s.form().fill(q="python web scraping")
s.submit(f, action="btnG", method="GET")</pre><p>Now that we have submitted our query, we can simply have a look at the HTML. If you compare the HTML of a page retrieved using FireFox and a page retrieved using the basic WWWClient, you will notice a difference: Google actually do some user-agent detection (such as many sites, like Freshmeat).</p><p>Looking at the HTML source code won't help that much, so that we can directly print a tree representation of the page:</p><pre>&gt;&gt;&gt; tree = scrape.HTML.tree(s.page())
&gt;&gt;&gt; print tree</pre><p>I won't reproduce the whole tree here, but if you study the tree, you will notice that the elements we are interested in are:</p><pre> +-- #text:u' '
 +-- p#264@4:class=g
     +-- a#265@5:href=http://www.lib.uwaterloo.ca/~cpgray/project.html, class=l
         +-- #text:u'Metadata on the '
         +-- b#266@6:
             +-- #text:u'Web'
 +-- table#267@4:cellpadding=0, border=0, cellspacing=0
     +-- tr#268@5:
         +-- td#269@6:class=j
             +-- font#270@7:size=-1
                 +-- #text:u'By using Zope with the '
                 +-- b#271@8:
                     +-- #text:u'python'
                 +-- #text:u' urllib '
                  +-- b#272@8:
                      +-- #text:u'Web'</pre><p>these are actually the link title (#264) and the link extract (#267). We notice that link titles are <code>&lt;p&gt;</code> of depth 4, and link descriptions are <code>&lt;table&gt;</code> of depth 4.</p><p>Let's introduce the <code>cut()</code> method of the tag tree:</p><dl><dt> cut</dt><dd><div class='content'><p>The <code>cut()</code> method allows to cut the tree so that it creates a subtree with all the nodes above, below, or in the cutting range.</p><p><code>tree.cut(below=4)</code> will return a subtree with all the nodes of the tree with a depth of 5 and more.</p><p><code>tree.cut(above=4)</code> will return a subtree with all the nodes of the tree with a depth of 3 or less.</p></div></dd><p>So the <code>cut()</code> method is actually what we are looking for, and calling</p></dl><pre>subtree = tree.cut(below=3)</pre><p>will return us the data node with depth 4 and more in a new tag tree. We may now want to keep only the <code>&lt;p&gt;</code> and <code>&lt;table&gt;</code> elements.</p><dl><dt> filter</dt><dd><div class='content'><p>The <code>filter()</code> method allows to create a new tag tree which content filtered by rejection (<code>reject</code>) or acceptation (<code>accept</code>) predicates.</p><pre>subtree = subtree.filter(accept=lambda n:n.name.lower() in ("table","p"))</pre></div></dd><p>If we print the subtree, we will notice that it is still quite complex, having both font tags, and split strings. Now, for each child of our subtree, we could try to use text-conversion method (which will be presented later):</p></dl><pre>for child in subtree.children:
    print "--------\n", HTML.text(child)</pre><p>The result is much more easy to read:</p><pre>----------
ASPN : Python Cookbook : Access password-protected web ...
----------
ActiveState Open Source Programming tools for Perl Python XML xslt scripting
with  free ... Title: Access password-protected web applications for
scraping. ...aspn.activestate.com/ASPN/Cookbook/Python/Recipe/391929 - 26k -
Cached - Similar&amp;nbsp;pages
----------
&amp;quot;&amp;quot;&amp;quot;Python module for web browsing and scraping. Done: - navigate ...
----------
&amp;quot;&amp;quot;&amp;quot;Python module for web browsing and scraping. Done: -
navigate to absolute and  relative URLs - follow links in page or region -
find strings or regular ...zesty.ca/python/scrape.py - 31k - Cached -
Similar&amp;nbsp;pages</pre><p>with this representation, we can confirm that we have extracted the right information.</p><p>If we want to select a particular subset of a node, like the <code>&lt;a&gt;</code> within the <code>&lt;p&gt;</code>, we can use the <code>elements()</code> method of the tag tree:</p><dl><dt> find</dt><dd><div class='content'><p>The <code>find()</code> method allows to return a subset of the descendants of the given node that have the given name (<code>elements(withName=...)</code>) or depth (<code>elements(withDepth=...)</code>).</p></div></dd><p>We can modify slightly the above script to print the link along with the title:</p></dl><pre>for node in nodes.children:
    print HTML.text(node)
    if node.name == "p":
        link = node.elements(withName="a")[0]
        print "--&gt;", link.attribute("href")
    else:
        print "---------"</pre><p>We've seen the basic <code>cut</code>, <code>filter</code> and <code>find</code> functions of the tag tree. They consist in the most useful operations you can do with the tag tree, and the ones you are the most likely to use in your everyday scraping duties.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Web automation</h2><div class="level2"><p>In addition to the basic tag tree operations, you can have access to higher level functions that will automatically extract <span class='term'>forms</span> and <span class='term'>links</span> for you.</p><dl><dt> forms</dt><dd><div class='content'><p>The forms method scrapes the HTML document for forms and inputs (including <code>textarea</code>, <code>select</code>, and all the likes). The scraping algorithm will manage some borderline cases, such as definition of fields outside of a form.</p><p>To use it, simply do:</p><pre>HTML.forms(tagtree or taglist or string)</pre></div></dd><dt> links</dt><dd><div class='content'><p>Pretty much like the <code>forms()</code> method, the <code>links()</code> method will return the list of links as <code>[(tagname, href),...]</code>. Links cover every HTML element that defines an <code>href</code> or <code>src</code> attribute, so that it includes images and iframes.</p><p>In the above example:</p><pre>&gt;&gt;&gt; HTML.links(link)
[(u'a', u'http://www.gossamer-threads.com/lists/python/python/516801')]</pre></div></dd><p>The web automation procedures all work with strings, tag list and tag trees, and are optimized for very fast information retrieval.</p></dl></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">4<span class="lastDot dot">.</span></span></span>Text processing functions</h2><div class="level2"><p>As we've seen, it is important to be able to easily convert between the string, the tag list and the tag tree. When manipulating the string representation, we may want to remove the HTML tags, normalize the spacing or expand the entities.</p><p>WWWClient offers functions to cover all these needs:</p><dl><dt> expand</dt><dd><div class='content'><p>This function takes a string with HTML entities, and returns a version of the string with expanded entities.</p><pre>&gt;&gt;&gt; scrape.HTML.expand("&amp;quot;&amp;quot;&amp;quot;Python")
'"""Python'</pre></div></dd><dt> norm</dt><dd><div class='content'><p>The <code>norm()</code> function replaces multiple spaces, tabs and newlines by a single space. This ensures that spacing in your text is consistent.</p></div></dd><dt> text</dt><dd><div class='content'><p>The <code>text()</code> method automatically strips the tags from your document (it is a bit like stripping the tags from a tag list), and returns the text version of it. You can set the <code>expand</code> and <code>norm</code> parameters to pass the result to the <code>expand</code> and <code>norm</code> functions</p></div></dd><dt> html</dt><dd><div class='content'><p>The <code>html()</code> method allows you to convert your taglist or tagtree to a string of HTML data. If you join a taglist created from an HTML string, it will be strictly identical to this string.</p></div></dd><p>In addition to these basic functions, you also have the following convenient functions:</p></dl><dl><dt> textcut</dt><dd><div class='content'><p>Textcut allows to specify <code>cutfrom</code> and <code>cutto</code> markers (as strings) that will delimit the text range to be returned. For instance if you are looking for the text between <code>&lt;p&gt;</code> and <code>&lt;/p&gt;</code>, you simply have to do:</p><pre>HTML.textcut(text, "&lt;p&gt;", "&lt;/p&gt;")</pre><p>When the markers are not found, the start or end bounds of the text are used instead.</p></div></dd><dt> textlines</dt><dd><div class='content'><p>Texlines allow to split your text in lines, optionally stripping (<code>strip</code>) the lines and filtering out empty lines (<code>empty</code>).</p></div></dd></dl></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">3<span class="lastDot dot">.</span></span></span>Tips</h1><div class="level1"><dl><dt> 1) Split your HTML into sections</dt><dd><div class='content'><p>Most HTML documents consist of different parts: headers, footers, navigation section, advertising, legal info, and actual content. It will be easier for you if you start by cutting and splitting your HTML document, getting rid of what you don't need and keeping what you are looking for.</p></div></dd><dt> 2) Get rid of HTML when you don't need structure</dt><dd><div class='content'><p>Manipulating HTML data can be difficult, especially when the document is not really well-formed. For instance, if you are scraping a document with table-formatted data, it may be complex to access the elements you need.</p><p>In this case, it may be a better option to cut and split your HTML so that you have your &ldquo;<span class='quote'>sections of data</span>&rdquo; at hand, and then convert them to text using <code>HTML.text(HTML.expand(html))</code>, and simply process the rest with the scraper module text processing tools or Python regular ones.</p></div></dd></dl></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">4<span class="lastDot dot">.</span></span></span>Text encoding support</h1><div class="level1"><p>As text data may come from various sources, some may be already encoded or not. To ensure that proper conversion is made, the following WWWClient elements feature an <code>encoding</code> property or argument to relevant methods that allows to specify in which encoding the given text data is encoded. This will ensure that the data is properly converted to raw strings before being passed to the transport layer (provided by the Curl library).</p><dl><dt> Session</dt><dd><div class='content'>Session encoding defines the default encoding for all the requests, cookies, headers, parameters, fields and provided data. Setting a session encoding will set every transaction, request and underlying curl handler encodings to the session one.</div></dd><dt> Form</dt><dd><div class='content'>when filling values within a form, the values will be converted to string when necessary. The given encoding will tell in which encoded the string should be coded.</div></dd></dl></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">5<span class="lastDot dot">.</span></span></span>Acknowledgments</h1><div class="level1"><p>I would like to thank Marc Carignan from <a href="http://www.xprima.com" class="external">Xprima.com</a> for giving me the opportunity to work on the WWWClient project and let it be open-sourced. This project could not have happened without his help, thanks Marc !</p><p>I would also like to thank the whole Python community for having created such an expressive, powerful language that have pleased me for years.</p></div></div></div></div>

</body>
</html>